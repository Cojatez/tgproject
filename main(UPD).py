import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)
import sqlite3
from datetime import datetime
import matplotlib.pyplot as plt
from io import BytesIO
from pytz import timezone
import uuid
import csv

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

TOKEN = "7650414135:AAH778jHnOVVQNjr_QFGjmv4Nv0pD6ZRajE"
DB_NAME = "organizer.db"
TIMEZONE = timezone('Europe/Moscow')

(
    TASK_STATES, EXPENSE_STATES, NOTE_STATES, REMINDER_STATES,
    SET_TASK, SET_PRIORITY, SET_DUE_DATE,
    SET_EXPENSE_AMOUNT, SET_EXPENSE_CATEGORY,
    SET_NOTE_TEXT, SET_NOTE_TAGS,
    SET_REMINDER_TEXT, SET_REMINDER_TIME
) = range(13)


def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS tasks
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  task TEXT,
                  priority INTEGER,
                  created DATETIME,
                  due DATETIME,
                  completed BOOLEAN)''')

    c.execute('''CREATE TABLE IF NOT EXISTS expenses
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  amount REAL,
                  category TEXT,
                  created DATETIME)''')

    c.execute('''CREATE TABLE IF NOT EXISTS notes
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  text TEXT,
                  tags TEXT,
                  created DATETIME)''')

    c.execute('''CREATE TABLE IF NOT EXISTS reminders
                 (id TEXT PRIMARY KEY,
                  user_id INTEGER,
                  text TEXT,
                  trigger_time DATETIME)''')

    conn.commit()
    conn.close()


init_db()


def get_main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("–ó–∞–¥–∞—á–∏", callback_data='tasks'),
         InlineKeyboardButton("–†–∞—Å—Ö–æ–¥—ã", callback_data='expenses')],
        [InlineKeyboardButton("–ó–∞–º–µ—Ç–∫–∏", callback_data='notes'),
         InlineKeyboardButton("–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data='reminders')]
    ])


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ', reply_markup=get_main_menu())
    return ConversationHandler.END


async def handle_new_members(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    for member in update.message.new_chat_members:
        if member.id == context.bot.id:
            welcome_text = """
            üëã –ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ª–∏—á–Ω—ã–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä.

            –ù–∞–ø–∏—à–∏ –º–Ω–µ /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É!
            """
            await update.message.reply_text(welcome_text)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    welcome_text = """
    üëã –ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ª–∏—á–Ω—ã–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä.

    –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ:
    - üìù –í–µ—Å—Ç–∏ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á
    - üí∞ –£—á–∏—Ç—ã–≤–∞—Ç—å —Ä–∞—Å—Ö–æ–¥—ã
    - üìå –°–æ—Ö—Ä–∞–Ω—è—Ç—å –∑–∞–º–µ—Ç–∫–∏
    - üîî –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è

    –í—ã–±–µ—Ä–∏ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª –≤ –º–µ–Ω—é –Ω–∏–∂–µ:
    """
    await update.message.reply_text(welcome_text, reply_markup=get_main_menu())


def get_tasks(user_id: int):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM tasks WHERE user_id=? AND completed=0 ORDER BY due", (user_id,))
    tasks = c.fetchall()
    conn.close()
    return tasks


def add_task(user_id: int, task: str, priority: int, due: datetime):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("INSERT INTO tasks (user_id, task, priority, created, due, completed) VALUES (?, ?, ?, ?, ?, 0)",
              (user_id, task, priority, datetime.now(), due))
    conn.commit()
    conn.close()


async def tasks_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data='add_task'),
         InlineKeyboardButton("–ú–æ–∏ –∑–∞–¥–∞—á–∏", callback_data='list_tasks')],
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='main_menu')]
    ]
    await query.edit_message_text(
        text="–ú–µ–Ω—é –∑–∞–¥–∞—á:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def list_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    tasks = get_tasks(user_id)

    if not tasks:
        await query.edit_message_text(text="–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á.", reply_markup=get_main_menu())
        return

    tasks_text = "–í–∞—à–∏ –∑–∞–¥–∞—á–∏:\n\n"
    for task in tasks:
        due_date = datetime.strptime(task[5], "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y %H:%M") if task[
            5] else "–Ω–µ—Ç —Å—Ä–æ–∫–∞"
        tasks_text += f"üìå {task[2]}\n–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {task[3]}\n–°—Ä–æ–∫: {due_date}\n\n"

    await query.edit_message_text(text=tasks_text, reply_markup=get_main_menu())


async def add_task_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(text="–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
    return SET_TASK


async def set_task(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['task'] = update.message.text
    await update.message.reply_text("–£–∫–∞–∂–∏—Ç–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (1-5):")
    return SET_PRIORITY


async def set_priority(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not update.message.text.isdigit() or not 1 <= int(update.message.text) <= 5:
        await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç! –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 5:")
        return SET_PRIORITY

    context.user_data['priority'] = int(update.message.text)
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ '–Ω–µ—Ç'):")
    return SET_DUE_DATE


async def set_due_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    due_date = None
    if update.message.text.lower() != '–Ω–µ—Ç':
        try:
            due_date = datetime.strptime(update.message.text, "%d.%m.%Y %H:%M")
            due_date = TIMEZONE.localize(due_date)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú:")
            return SET_DUE_DATE

    add_task(
        update.message.from_user.id,
        context.user_data['task'],
        context.user_data['priority'],
        due_date
    )
    await update.message.reply_text("–ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞!", reply_markup=get_main_menu())
    return ConversationHandler.END


async def expenses_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥", callback_data='add_expense'),
         InlineKeyboardButton("–ú–æ–∏ —Ä–∞—Å—Ö–æ–¥—ã", callback_data='list_expenses')],
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='main_menu')]
    ]
    await query.edit_message_text(
        text="–ú–µ–Ω—é —Ä–∞—Å—Ö–æ–¥–æ–≤:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def notes_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É", callback_data='add_note'),
         InlineKeyboardButton("–ú–æ–∏ –∑–∞–º–µ—Ç–∫–∏", callback_data='list_notes')],
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='main_menu')]
    ]
    await query.edit_message_text(
        text="–ú–µ–Ω—é –∑–∞–º–µ—Ç–æ–∫:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def reminders_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ", callback_data='add_reminder'),
         InlineKeyboardButton("–ú–æ–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è", callback_data='list_reminders')],
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='main_menu')]
    ]
    await query.edit_message_text(
        text="–ú–µ–Ω—é –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(text="–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_menu())


async def send_reminder_callback(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    await context.bot.send_message(
        chat_id=job.data['user_id'],
        text=f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {job.data['text']}"
    )
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("DELETE FROM reminders WHERE id=?", (job.name,))
    conn.commit()
    conn.close()


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(msg="Exception while handling an update:", exc_info=context.error)


def main() -> None:
    application = Application.builder().token(TOKEN).build()


    task_conv_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(add_task_handler, pattern='^add_task$')],
        states={
            SET_TASK: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_task)],
            SET_PRIORITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_priority)],
            SET_DUE_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_due_date)]
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )


    application.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, handle_new_members))
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CallbackQueryHandler(tasks_menu, pattern='^tasks$'))
    application.add_handler(CallbackQueryHandler(expenses_menu, pattern='^expenses$'))
    application.add_handler(CallbackQueryHandler(notes_menu, pattern='^notes$'))
    application.add_handler(CallbackQueryHandler(reminders_menu, pattern='^reminders$'))
    application.add_handler(CallbackQueryHandler(main_menu, pattern='^main_menu$'))
    application.add_handler(CallbackQueryHandler(list_tasks, pattern='^list_tasks$'))
    application.add_handler(task_conv_handler)
    application.add_error_handler(error_handler)


    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM reminders")
    for reminder in c.fetchall():
        trigger_time = datetime.strptime(reminder[3], "%Y-%m-%d %H:%M:%S")
        if trigger_time > datetime.now():
            application.job_queue.run_once(
                send_reminder_callback,
                (trigger_time - datetime.now()).total_seconds(),
                data={'user_id': reminder[1], 'text': reminder[2]},
                name=reminder[0]
            )
    conn.close()

    application.run_polling()


if __name__ == "__main__":
    main()